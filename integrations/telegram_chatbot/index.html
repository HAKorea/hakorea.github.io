<!doctype html>
  <!--[if lt IE 7]>      <html lang="en" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
  <!--[if IE 7]>         <html lang="en" class="no-js lt-ie9 lt-ie8"> <![endif]-->
  <!--[if IE 8]>         <html lang="en" class="no-js lt-ie9"> <![endif]-->
  <!--[if gt IE 8]><!--> <html lang="en"> <!--<![endif]-->
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>텔레그램 챗봇 (Telegram chatbot) - 홈어시스턴트</title>
    <meta name="author" content="Home Assistant">
    <meta name="description" content="Telegram chatbot support">
    
    <meta name="viewport" content="width=device-width">
    <link rel="canonical" href="https://hakorea.github.io/integrations/telegram_chatbot/">

    <meta property="fb:app_id" content="">
    <meta property="og:title" content="텔레그램 챗봇 (Telegram chatbot)">
    <meta property="og:site_name" content="홈어시스턴트">
    <meta property="og:url" content="https://hakorea.github.io/integrations/telegram_chatbot/">
    <meta property="og:type" content="article">
    <meta property="og:description" content="Telegram chatbot support">
    <meta property="og:image" content="https://hakorea.github.io/images/default-social.png">
    
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@">
    
    <meta name="twitter:title" content="텔레그램 챗봇 (Telegram chatbot)">
    <meta name="twitter:description" content="Telegram chatbot support">
    <meta name="twitter:image" content="https://hakorea.github.io/images/default-social.png">

    <link href="/stylesheets/prism.css?8acb84bc0387c9548a63998fcfea0139" rel="stylesheet">
    <link href="/stylesheets/screen.css?0a23d70030bf362ca935e76ccc50922c" media="screen, projection, print" rel="stylesheet">
    <link href="/atom.xml" rel="alternate" title="홈어시스턴트" type="application/atom+xml">
    <link rel='shortcut icon' href='/images/favicon.ico' />
    <link rel='icon' type='image/png' href='/images/favicon-192x192.png' sizes='192x192' />
  </head>

  <body >

    <header class='site-header'>
      <div class="grid-wrapper">
  <div class="grid">
    <div class="grid__item three-tenths lap-two-sixths palm-one-whole ha-title">
      <a href="/" class="site-title">
        <img src="/images/home-assistant-logo.png" width="36" height="36" alt="Home Assistant">
        <span>홈어시스턴트</span>
      </a>
    </div>

    <div class="grid__item seven-tenths lap-four-sixths palm-one-whole">
      <nav>
        <input type="checkbox" id="toggle">
        <label for="toggle" class="toggle" data-open="Main Menu" data-close="Close Menu"></label>
        <ul class="menu pull-right">
            
            <li><a href="/getting-started/">시작하기</a></li>
            <li><a href="/integrations/">통합구성요소</a></li>
            <li><a href="/docs/">문서</a></li>
            <li><a href="/cookbook/">예제</a></li>
            <li><a href='#' class='show-search'><i class="icon-search"></i></a></li>
            <li>KOREAN(not official)</li>
        </ul>
      </nav>

      <div class='search-container' style='display: none'>
        <div class='search'>
          <i class="icon-search"></i>
          <input id='search' placeholder='Search the docs…'>
          <a href='#' class='close'><i class="icon-remove-sign"></i></a>
        </div>
      </div>
    </div>
  </div>
</div>

    </header>

    

    <div class="grid-wrapper">
      <div class="grid grid-center">
        
        <div class="grid__item two-thirds lap-one-whole palm-one-whole">
        

          
            <article class="page">
  
  
    

<div class="edit-github"><a href="https://github.com/hakorea/gitpages_source/blob/master/source/_integrations/telegram_chatbot.markdown" rel="external nofollow">깃허브 편집</a></div>


  

  
  <header>
    <h1 class="title indent">
      텔레그램 챗봇 (Telegram chatbot)
    </h1>
  </header>
  <hr class="divider">
  

  <p>모바일 또는 데스크톱 장치에서 송수신 기능을 사용하여 홈 어시스턴트와 메시지 또는 명령을 주고받습니다.</p>
<p>이 통합구성요소는 <a href="/integrations/telegram_polling">polling</a> 플랫폼 또는 다음으로 구성된 <a href="https://core.telegram.org/bots" rel="external nofollow">Telegram Bot account</a>에서 메시지를 보내거나 이전에 보낸 메시지를 편집하는 알림 서비스를 만듭니다. <a href="/integrations/telegram_webhooks">webhooks</a> 및 메시지 수신시 이벤트를 트리거합니다.</p>
<p>메시지를 받을 필요가 없는 경우 <a href="/integrations/telegram_broadcast">broadcast</a> 플랫폼을 대신 사용할 수 있습니다.</p>
<h2>
<a class="title-link" name="-" href="#-"></a> 알림 서비스</h2>
<p>제공 서비스 : <code>send_message</code>, <code>send_photo</code>, <code>send_document</code>, <code>send_location</code>, <code>send_sticker</code>, <code>edit_message</code>, <code>edit_replymarkup</code>, <code>edit_caption</code>, <code>answer_callback_query</code>, <code>delete_message</code>, <code>leave_chat</code>.</p>
<h3>
<a class="title-link" name="telegram_botsend_message-" href="#telegram_botsend_message-"></a> telegram_bot.send_message 서비스</h3>
<p>알림을 보냅니다.</p>
<table>
<thead>
<tr>
<th>Service data attribute</th>
<th>Optional</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>message</code></td>
<td>no</td>
<td>알림의 메시지 본문.</td>
</tr>
<tr>
<td><code>title</code></td>
<td>yes</td>
<td>알림의 제목입니다. 예: ‘%title\n%message’.</td>
</tr>
<tr>
<td><code>target</code></td>
<td>yes</td>
<td>알림을 보낼 사전 승인 된 chat_id 또는 user_id의 배열. 첫 번째로 허용되는 chat_id가 기본값.</td>
</tr>
<tr>
<td><code>parse_mode</code></td>
<td>yes</td>
<td>메시지 텍스트 파서: <code>html</code> 혹은 <code>markdown</code>.</td>
</tr>
<tr>
<td><code>disable_notification</code></td>
<td>yes</td>
<td>메시지를 자동으로 보내기위한 True/False. iOS 사용자와 웹 사용자는 알림을받지 않으며, Android 사용자는 소리없이 알림을 받습니다. 기본값은 False.</td>
</tr>
<tr>
<td><code>disable_web_page_preview</code></td>
<td>yes</td>
<td>메시지의 링크에 대한 링크 미리보기를 사용하지 않는 경우 True/false.</td>
</tr>
<tr>
<td><code>keyboard</code></td>
<td>yes</td>
<td>사용자 정의 키보드를 만들기 위한 쉼표로 구분 된 명령 행 목록. <code>[]</code>로 사용자 정의 키보드가 없는 것으로 재설정. 예:<code>["/command1, /command2", "/command3"]</code>
</td>
</tr>
<tr>
<td><code>inline_keyboard</code></td>
<td>yes</td>
<td>콜백 데이터가 연결된 버튼이있는 사용자 지정 인라인 키보드를 만들기 위해 쉼표로 구분 된 명령 행 목록. 예:  <code>["/button1, /button2", "/button3"]</code> or <code>[[["Text btn1", "/button1"], ["Text btn2", "/button2"]], [["Text btn3", "/button3"]]]</code>
</td>
</tr>
</tbody>
</table>
<h3>
<a class="title-link" name="telegram_botsend_photo--telegram_botsend_sticker-" href="#telegram_botsend_photo--telegram_botsend_sticker-"></a> telegram_bot.send_photo 및 telegram_bot.send_sticker 서비스</h3>
<p>사진을 보냅니다.</p>
<table>
<thead>
<tr>
<th>Service data attribute</th>
<th>Optional</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>url</code></td>
<td>no</td>
<td>이미지의 원격 경로.</td>
</tr>
<tr>
<td><code>file</code></td>
<td>no</td>
<td>이미지의 로컬 경로.</td>
</tr>
<tr>
<td><code>caption</code></td>
<td>yes</td>
<td>이미지의 제목.</td>
</tr>
<tr>
<td><code>username</code></td>
<td>yes</td>
<td>HTTP 기본 인증이 필요한 URL의 사용자 이름.</td>
</tr>
<tr>
<td><code>password</code></td>
<td>yes</td>
<td>HTTP 기본 인증이 필요한 URL의 비밀번호.</td>
</tr>
<tr>
<td><code>authentication</code></td>
<td>yes</td>
<td>사용할 인증 방법을 정의하십시오. <code>digest</code>는 HTTP 다이제스트 인증을 사용합니다. 기본은 <code>basic</code> 입니다.</td>
</tr>
<tr>
<td><code>target</code></td>
<td>yes</td>
<td>알림을 보낼 사전 승인 된 chat_id 또는 user_id의 배열입니다. 첫 번째로 허용되는 chat_id가 기본값.</td>
</tr>
<tr>
<td><code>disable_notification</code></td>
<td>yes</td>
<td>메시지를 조용히 보내기 True/false. iOS 사용자와 웹 사용자는 알림을 받지 않으며, Android 사용자는 소리없이 알림을 받습니다. 기본값은 False.</td>
</tr>
<tr>
<td><code>verify_ssl</code></td>
<td>yes</td>
<td>HTTPS URL에 대한 서버의 SSL 인증서를 확인하는 경우 True / false. 기본값은 True.</td>
</tr>
<tr>
<td><code>keyboard</code></td>
<td>yes</td>
<td>커스텀 키보드를 만들기 위한 쉼표로 구분 된 명령행 목록. <code>[]</code>로 사용자 정의 키보드가 없는 것으로 재설정. 예:<code>["/command1, /command2", "/command3"]</code>
</td>
</tr>
<tr>
<td><code>inline_keyboard</code></td>
<td>yes</td>
<td>연관된 콜백 데이터가 있는 버튼으로 사용자 정의 인라인 키보드를 만들기 위한 쉼표로 구분된 명령행 목록. 예: <code>["/button1, /button2", "/button3"]</code> or <code>[[["Text btn1", "/button1"], ["Text btn2", "/button2"]], [["Text btn3", "/button3"]]]</code>
</td>
</tr>
</tbody>
</table>
<h3>
<a class="title-link" name="telegram_botsend_video-" href="#telegram_botsend_video-"></a> telegram_bot.send_video 서비스</h3>
<p>비디오 보내기.</p>
<table>
<thead>
<tr>
<th>Service data attribute</th>
<th>Optional</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>url</code></td>
<td>no</td>
<td>비디오의 원격 경로.</td>
</tr>
<tr>
<td><code>file</code></td>
<td>no</td>
<td>비디오의 로컬 경로.</td>
</tr>
<tr>
<td><code>caption</code></td>
<td>yes</td>
<td>비디오의 제목.</td>
</tr>
<tr>
<td><code>username</code></td>
<td>yes</td>
<td>HTTP 기본 인증이 필요한 URL의 사용자 이름.</td>
</tr>
<tr>
<td><code>password</code></td>
<td>yes</td>
<td>HTTP 기본 인증이 필요한 URL의 비밀번호.</td>
</tr>
<tr>
<td><code>authentication</code></td>
<td>yes</td>
<td>사용할 인증 방법을 정의하십시오. <code>digest</code>는 HTTP 다이제스트 인증을 사용합니다. 기본은 <code>basic</code> 입니다.</td>
</tr>
<tr>
<td><code>target</code></td>
<td>yes</td>
<td>알림을 보낼 사전 승인 된 chat_id 또는 user_id의 배열입니다. 첫 번째로 허용되는 chat_id가 기본값입니다.</td>
</tr>
<tr>
<td><code>disable_notification</code></td>
<td>yes</td>
<td>메시지를 자동으로 보내려면 True/False 입니다. iOS 사용자와 웹 사용자는 알림을 받지 않습니다. Android 사용자에게는 소리가 들리지 않는 알림이 수신됩니다. 기본값은 False입니다.</td>
</tr>
<tr>
<td><code>verify_ssl</code></td>
<td>yes</td>
<td>HTTPS URL에 대한 서버의 SSL 인증서를 확인하는 True/False 기본값은 True.</td>
</tr>
<tr>
<td><code>keyboard</code></td>
<td>yes</td>
<td>커스텀 키보드를 만들기 위한 쉼표로 구분 된 명령행 목록. <code>[]</code>로 사용자 정의 키보드가 없는 것으로 재설정. 예:<code>["/command1, /command2", "/command3"]</code>
</td>
</tr>
<tr>
<td><code>inline_keyboard</code></td>
<td>yes</td>
<td>연관된 콜백 데이터가 있는 버튼으로 사용자 정의 인라인 키보드를 만들기 위한 쉼표로 구분된 명령행 목록. 예: <code>["/button1, /button2", "/button3"]</code> or <code>[[["Text btn1", "/button1"], ["Text btn2", "/button2"]], [["Text btn3", "/button3"]]]</code>
</td>
</tr>
</tbody>
</table>
<h3>
<a class="title-link" name="telegram_botsend_document-" href="#telegram_botsend_document-"></a> telegram_bot.send_document 서비스</h3>
<p>문서를 보냅니다.</p>
<table>
<thead>
<tr>
<th>Service data attribute</th>
<th>Optional</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>url</code></td>
<td>no</td>
<td>문서의 원격 경로.</td>
</tr>
<tr>
<td><code>file</code></td>
<td>no</td>
<td>문서의 로컬 경로.</td>
</tr>
<tr>
<td><code>caption</code></td>
<td>yes</td>
<td>문서의 제목.</td>
</tr>
<tr>
<td><code>username</code></td>
<td>yes</td>
<td>HTTP 기본 인증이 필요한 URL의 사용자 이름.</td>
</tr>
<tr>
<td><code>password</code></td>
<td>yes</td>
<td>HTTP 기본 인증이 필요한 URL의 비밀번호.</td>
</tr>
<tr>
<td><code>authentication</code></td>
<td>yes</td>
<td>사용할 인증 방법을 정의하십시오. <code>digest</code>는 HTTP 다이제스트 인증을 사용합니다. 기본은 <code>basic</code> 입니다.</td>
</tr>
<tr>
<td><code>target</code></td>
<td>yes</td>
<td>알림을 보낼 사전 승인된 chat_id 또는 user_id의 배열입니다. 첫 번째로 허용되는 chat_id가 기본값입니다.</td>
</tr>
<tr>
<td><code>disable_notification</code></td>
<td>yes</td>
<td>메시지를 자동으로 보내려면 True/False 입니다. iOS 사용자와 웹 사용자는 알림을 받지 않습니다. Android 사용자에게는 소리가 들리지 않는 알림이 수신됩니다. 기본값은 False입니다.</td>
</tr>
<tr>
<td><code>verify_ssl</code></td>
<td>yes</td>
<td>HTTPS URL에 대한 서버의 SSL 인증서를 확인하는 True/False 기본값은 True.</td>
</tr>
<tr>
<td><code>keyboard</code></td>
<td>yes</td>
<td>커스텀 키보드를 만들기 위한 쉼표로 구분 된 명령행 목록. <code>[]</code>로 사용자 정의 키보드가 없는 것으로 재설정. 예:<code>["/command1, /command2", "/command3"]</code>
</td>
</tr>
<tr>
<td><code>inline_keyboard</code></td>
<td>yes</td>
<td>연관된 콜백 데이터가 있는 버튼으로 사용자 정의 인라인 키보드를 만들기 위한 쉼표로 구분된 명령행 목록. 예: <code>["/button1, /button2", "/button3"]</code> or <code>[[["Text btn1", "/button1"], ["Text btn2", "/button2"]], [["Text btn3", "/button3"]]]</code>
</td>
</tr>
</tbody>
</table>
<h3>
<a class="title-link" name="telegram_botsend_location-" href="#telegram_botsend_location-"></a> telegram_bot.send_location 서비스</h3>
<p>위치를 전송합니다.</p>
<table>
<thead>
<tr>
<th>Service data attribute</th>
<th>Optional</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>latitude</code></td>
<td>no</td>
<td>보낼 위도.</td>
</tr>
<tr>
<td><code>longitude</code></td>
<td>no</td>
<td>보낼 경도.</td>
</tr>
<tr>
<td><code>target</code></td>
<td>yes</td>
<td>알림을 보낼 사전 승인 된 chat_id 또는 user_id의 배열입니다. 첫 번째로 허용되는 <code>chat_id</code>가 기본값입니다.</td>
</tr>
<tr>
<td><code>disable_notification</code></td>
<td>yes</td>
<td>메시지를 자동으로 보내려면 True / false입니다. iOS 사용자와 웹 사용자는 알림을받지 않으며, Android 사용자는 소리없이 알림을받습니다. 기본값은 False입니다.</td>
</tr>
<tr>
<td><code>keyboard</code></td>
<td>yes</td>
<td>커스텀 키보드를 만들기 위한 쉼표로 구분 된 명령행 목록. <code>[]</code>로 사용자 정의 키보드가 없는 것으로 재설정. 예:<code>["/command1, /command2", "/command3"]</code>
</td>
</tr>
<tr>
<td><code>inline_keyboard</code></td>
<td>yes</td>
<td>연관된 콜백 데이터가 있는 버튼으로 사용자 정의 인라인 키보드를 만들기 위한 쉼표로 구분된 명령행 목록. 예: <code>["/button1, /button2", "/button3"]</code> or <code>[[["Text btn1", "/button1"], ["Text btn2", "/button2"]], [["Text btn3", "/button3"]]]</code>
</td>
</tr>
</tbody>
</table>
<h3>
<a class="title-link" name="telegram_botedit_message-" href="#telegram_botedit_message-"></a> telegram_bot.edit_message 서비스</h3>
<p>대화에서 이전에 보낸 메시지를 편집합니다.</p>
<table>
<thead>
<tr>
<th>Service data attribute</th>
<th>Optional</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>message_id</code></td>
<td>no</td>
<td>편집할 메시지의 ID. 누른 버튼에서 콜백에 응답할 때 원본 메시지의 ID는 <code>{{trigger.event.data.message.message_id}}</code>에 있습니다. <code>"last"</code>를 사용하여 <code>chat_id</code>에 전송된 마지막 메시지 참조 가능.</td>
</tr>
<tr>
<td><code>chat_id</code></td>
<td>no</td>
<td>메시지를 편집할 chat_id.</td>
</tr>
<tr>
<td><code>message</code></td>
<td>no</td>
<td>알림 메시지 본문.</td>
</tr>
<tr>
<td><code>title</code></td>
<td>yes</td>
<td>알림의 제목입니다. ‘% title \ n % message’로 구성됩니다.</td>
</tr>
<tr>
<td><code>parse_mode</code></td>
<td>yes</td>
<td>메시지 텍스트 파서 : <code>html</code> 혹은 <code>markdown</code>.</td>
</tr>
<tr>
<td><code>disable_web_page_preview</code></td>
<td>yes</td>
<td>메시지의 링크에 대한 링크 미리보기를 사용하지 않도록 설정하는 경우 True/False.</td>
</tr>
<tr>
<td><code>inline_keyboard</code></td>
<td>yes</td>
<td>연관된 콜백 데이터가 있는 버튼으로 사용자 정의 인라인 키보드를 만들기 위한 쉼표로 구분된 명령행 목록. 예: <code>["/button1, /button2", "/button3"]</code> or <code>[[["Text btn1", "/button1"], ["Text btn2", "/button2"]], [["Text btn3", "/button3"]]]</code>
</td>
</tr>
</tbody>
</table>
<h3>
<a class="title-link" name="telegram_botedit_caption-" href="#telegram_botedit_caption-"></a> telegram_bot.edit_caption 서비스</h3>
<p>이전에 보낸 메시지의 캡션을 편집합니다.</p>
<table>
<thead>
<tr>
<th>Service data attribute</th>
<th>Optional</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>message_id</code></td>
<td>no</td>
<td>편집할 메시지의 ID. 누른 버튼에서 콜백에 응답할 때 원본 메시지의 ID는 <code>{{trigger.event.data.message.message_id}}</code>에 있습니다. <code>"last"</code>를 사용하여 <code>chat_id</code>에 전송된 마지막 메시지 참조 가능.</td>
</tr>
<tr>
<td><code>chat_id</code></td>
<td>no</td>
<td>캡션을 편집 할 chat_id.</td>
</tr>
<tr>
<td><code>caption</code></td>
<td>no</td>
<td>알림의 메시지 본문.</td>
</tr>
<tr>
<td><code>disable_web_page_preview</code></td>
<td>yes</td>
<td>메시지의 링크에 대한 링크 미리보기를 사용하지 않도록 설정하는 경우 True/False.</td>
</tr>
<tr>
<td><code>inline_keyboard</code></td>
<td>yes</td>
<td>연관된 콜백 데이터가 있는 버튼으로 사용자 정의 인라인 키보드를 만들기 위한 쉼표로 구분된 명령행 목록. 예: <code>["/button1, /button2", "/button3"]</code> or <code>[[["Text btn1", "/button1"], ["Text btn2", "/button2"]], [["Text btn3", "/button3"]]]</code>
</td>
</tr>
</tbody>
</table>
<h3>
<a class="title-link" name="telegram_botedit_replymarkup-" href="#telegram_botedit_replymarkup-"></a> telegram_bot.edit_replymarkup 서비스</h3>
<p>이전에 보낸 메시지의 인라인 키보드를 편집합니다.</p>
<table>
<thead>
<tr>
<th>Service data attribute</th>
<th>Optional</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>message_id</code></td>
<td>no</td>
<td>편집할 메시지의 ID. 누른 버튼에서 콜백에 응답할 때 원본 메시지의 ID는 <code>{{trigger.event.data.message.message_id}}</code>에 있습니다. <code>"last"</code>를 사용하여 <code>chat_id</code>에 전송된 마지막 메시지 참조 가능.</td>
</tr>
<tr>
<td><code>chat_id</code></td>
<td>no</td>
<td>reply_markup을 편집 할 수있는 chat_id.</td>
</tr>
<tr>
<td><code>disable_web_page_preview</code></td>
<td>yes</td>
<td>메시지의 링크에 대한 링크 미리보기를 사용하지 않도록 설정하는 경우 True/False.</td>
</tr>
<tr>
<td><code>inline_keyboard</code></td>
<td>yes</td>
<td>연관된 콜백 데이터가 있는 버튼으로 사용자 정의 인라인 키보드를 만들기 위한 쉼표로 구분된 명령행 목록. 예: <code>["/button1, /button2", "/button3"]</code> 혹은 <code>[[["Text btn1", "/button1"], ["Text btn2", "/button2"]], [["Text btn3", "/button3"]]]</code>
</td>
</tr>
</tbody>
</table>
<h3>
<a class="title-link" name="telegram_botanswer_callback_query-" href="#telegram_botanswer_callback_query-"></a> telegram_bot.answer_callback_query 서비스</h3>
<p>온라인 키보드 버튼을 클릭하여 생성 된 콜백 쿼리에 응답합니다. 답변은 채팅 화면 상단에 알림 또는 경보으로 사용자에게 표시됩니다.</p>
<table>
<thead>
<tr>
<th>Service data attribute</th>
<th>Optional</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>message</code></td>
<td>no</td>
<td>알림의 형식이 지정되지 않은 문자 메시지 본문.</td>
</tr>
<tr>
<td><code>callback_query_id</code></td>
<td>no</td>
<td>콜백 응답의 고유 ID <code>telegram_callback</code> 이벤트 데이터: <code>{{ trigger.event.data.id }}</code>
</td>
</tr>
<tr>
<td><code>show_alert</code></td>
<td>yes</td>
<td>영구 알림(permanent notification)을 표시하려면 True/false입니다. 기본값은 False입니다.</td>
</tr>
</tbody>
</table>
<h3>
<a class="title-link" name="telegram_botdelete_message-" href="#telegram_botdelete_message-"></a> telegram_bot.delete_message 서비스</h3>
<p>대화에서 이전에 보낸 메시지를 삭제합니다.</p>
<table>
<thead>
<tr>
<th>Service data attribute</th>
<th>Optional</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>message_id</code></td>
<td>no</td>
<td>메시지의 ID를 삭제하십시오. 누른 버튼으로 콜백에 응답하면 원래 메시지의 ID : <code>{{ trigger.event.data.message.message_id }}</code>. <code>"last"</code>를 사용하여 <code>chat_id</code>에 전송된 마지막 메시지 참조 가능.</td>
</tr>
<tr>
<td><code>chat_id</code></td>
<td>no</td>
<td>메시지를 삭제할 chat_id.</td>
</tr>
</tbody>
</table>
<h3>
<a class="title-link" name="telegram_botleave_chat-" href="#telegram_botleave_chat-"></a> telegram_bot.leave_chat 서비스</h3>
<p>추가된 채팅 그룹에서 봇을 제거합니다.</p>
<table>
<thead>
<tr>
<th>Service data attribute</th>
<th>Optional</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>chat_id</code></td>
<td>no</td>
<td>봇을 제거 할 위치의 chat_id</td>
</tr>
</tbody>
</table>
<h2>
<a class="title-link" name="telegram--" href="#telegram--"></a> telegram 알림 플랫폼</h2>
<p><a href="/integrations/telegram"><code>telegram</code> notification platform</a>을 작동하기 위해 <code>telegram_bot</code> 연동이 필요하며 알림 (메시지, 사진, 문서 및 위치)을 전송하기 위한 사용자 정의 단축키 (<code>notify.USERNAME</code>)를 생성하도록 설계되었습니다. 이전 문법으로 특정 <code>chat_id</code>에 추가하여 이전 버전과의 호환성을 허용합니다.</p>
<p>필요한 YAML 설정은 다음같이 줄어듭니다. :</p>
<pre><code class="language-yaml">notify:
  - name: NOTIFIER_NAME
    platform: telegram
    chat_id: USER_CHAT_ID
</code></pre>
<h2>
<a class="title-link" name="--event-triggering" href="#--event-triggering"></a> 이벤트 트리거 (Event triggering)</h2>
<p><code>/thecommand</code> 혹은 <code>/othercommand with some args</code> 같은 것들을.</p>
<p>홈어시스턴트가 수신하면 이벤트 버스에서 <code>telegram_command</code> 이벤트를 다음과 같은 <code>event_data</code>와 함께 시작합니다. :</p>
<pre><code class="language-yaml">command: "/thecommand"
args: "&lt;any other text following the command&gt;"
from_first: "&lt;first name of the sender&gt;"
from_last: "&lt;last name of the sender&gt;"
user_id: "&lt;id of the sender&gt;"
chat_id: "&lt;origin chat id&gt;"
chat: "&lt;chat info&gt;"
</code></pre>
<p><code>/</code>로 시작하지 않는 다른 메시지는 간단한 텍스트로 처리되어 이벤트 버스에서 <code>telegram_text</code> 이벤트를 다음과 같은 <code>event_data</code> :</p>
<pre><code class="language-yaml">text: "some text received"
from_first: "&lt;first name of the sender&gt;"
from_last: "&lt;last name of the sender&gt;"
user_id: "&lt;id of the sender&gt;"
chat_id: "&lt;origin chat id&gt;"
chat: "&lt;chat info&gt;"
</code></pre>
<p>예를 들어 <a href="https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating" rel="external nofollow">press from an inline button</a>에서 메시지가 전송되면 콜백 쿼리가 수신됩니다. 홈어시스턴트는 다음과 같이 <code>telegram_callback</code> 이벤트를 시작합니다.</p>
<pre><code class="language-yaml">data: "&lt;data associated to action callback&gt;"
message: &lt;message origin of the action callback&gt;
from_first: "&lt;first name of the sender&gt;"
from_last: "&lt;last name of the sender&gt;"
user_id: "&lt;id of the sender&gt;"
id: "&lt;unique id of the callback&gt;"
chat_instance: "&lt;chat instance&gt;"
chat_id: "&lt;origin chat id&gt;"
</code></pre>
<h3>
<a class="title-link" name="-" href="#-"></a> 설정 샘플</h3>
<p>간단한 핑퐁 사례</p>
<pre><code class="language-yaml">alias: 'Telegram bot that reply pong to ping'
trigger:
  platform: event
  event_type: telegram_command
  event_data:
    command: '/ping'
action:
  - service: notify.notify
    data:
      message: 'pong'
</code></pre>
<p><code>notify.telegram</code>과의 키보드 상호 작용을 보여주는 예</p>
<pre><code class="language-yaml">trigger:
  platform: event
  event_type: telegram_command
  event_data:
    command: '/start'
action:
  - service: notify.telegram
    data:
      message: 'commands'
      data:
        keyboard:
          - '/ping, /alarm'
          - '/siren'
</code></pre>
<p>관련 명령 “/ siren”을 트리거하는 자동화.</p>
<pre><code class="language-yaml">trigger:
  platform: event
  event_type: telegram_command
  event_data:
    command: '/siren'
action:
  - service: homeassistant.turn_on
    entity_id: switch.vision_zm1601eu5_battery_operated_siren_switch_9_0
  - delay:
      seconds: 10
  - service: homeassistant.turn_off
    entity_id: switch.vision_zm1601eu5_battery_operated_siren_switch_9_0
</code></pre>
<p>실제 event_data 사용을 보여주는 예제 :</p>
<pre><code class="language-yaml">- alias: 'Kitchen Telegram Speak'
  trigger:
    platform: event
    event_type: telegram_command
    event_data:
      command: '/speak'
  action:
    - service: notify.kitchen_echo
      data_template:
        message: &gt;
          Message from {{ trigger.event.data["from_first"] }}. {% for state in trigger.event.data["args"] %} {{ state }} {% endfor %}
</code></pre>
<h3>
<a class="title-link" name="-------" href="#-------"></a> 콜백 쿼리 및 인라인 키보드를 사용한 샘플 자동화</h3>
<p>‘EDIT’, ‘NO’ 및 ‘REMOVE BUTTON’ 버튼이 있는 인라인 키보드를 표시하는 일반 텍스트의 간단한 리피터로 구성된 단순한 자동화 기능을 갖춘 인라인 키보드의 일부 콜백 기능을 보여주는 간단한 예</p>
<ul>
<li>‘EDIT’, ‘NO’ 및 ‘REMOVE BUTTON’</li>
<li>‘NO’를 누르면 간단한 알림 만 표시됩니다. (콜백 쿼리에 응답).</li>
<li>‘REMOVE BUTTON’를 누르면 해당 버튼을 제거하는 인라인 키보드가 변경됩니다.</li>
</ul>
<p>텍스트 반복 :</p>
<pre><code class="language-yaml">- alias: 'Telegram bot that repeats text'
  trigger:
    platform: event
    event_type: telegram_text
  action:
    - service: telegram_bot.send_message
      data_template:
        title: '*Dumb automation*'
        target: '{{ trigger.event.data.user_id }}'
        message: 'You said: {{ trigger.event.data.text }}'
        disable_notification: true
        inline_keyboard:
          - "Edit message:/edit_msg, Don't:/do_nothing"
          - "Remove this button:/remove button"
</code></pre>
<p>메시지 에디터 :</p>
<pre><code class="language-yaml">- alias: 'Telegram bot that edits the last sent message'
  trigger:
    platform: event
    event_type: telegram_callback
    event_data:
      command: '/edit_msg'
  action:
    - service: telegram_bot.answer_callback_query
      data_template:
        callback_query_id: '{{ trigger.event.data.id }}'
        message: 'Editing the message!'
        show_alert: true
    - service: telegram_bot.edit_message
      data_template:
        message_id: '{{ trigger.event.data.message.message_id }}'
        chat_id: '{{ trigger.event.data.chat_id }}'
        title: '*Message edit*'
        inline_keyboard:
          - "Edit message:/edit_msg, Don't:/do_nothing"
          - "Remove this button:/remove button"
        message: &gt;
          Callback received from {{ trigger.event.data.from_first }}.
          Message id: {{ trigger.event.data.message.message_id }}.
          Data: {{ trigger.event.data.data }}
</code></pre>
<p>키보드 에디터 :</p>
<pre><code class="language-yaml">- alias: 'Telegram bot that edits the keyboard'
  trigger:
    platform: event
    event_type: telegram_callback
    event_data:
      command: '/remove button'
  action:
    - service: telegram_bot.answer_callback_query
      data_template:
        callback_query_id: '{{ trigger.event.data.id }}'
        message: 'Callback received for editing the inline keyboard!'
    - service: telegram_bot.edit_replymarkup
      data_template:
        message_id: 'last'
        chat_id: '{{ trigger.event.data.chat_id }}'
        inline_keyboard:
          - "Edit message:/edit_msg, Don't:/do_nothing"
</code></pre>
<p>‘NO’ 답변만 인지 :</p>
<pre><code class="language-yaml">- alias: 'Telegram bot that simply acknowledges'
  trigger:
    platform: event
    event_type: telegram_callback
    event_data:
      command: '/do_nothing'
  action:
    - service: telegram_bot.answer_callback_query
      data_template:
        callback_query_id: '{{ trigger.event.data.id }}'
        message: 'OK, you said no!'
</code></pre>
<p>텔레 그램 콜백은 일반 메시지와 동일한 방식으로 인수 및 명령을 지원합니다.</p>
<pre><code class="language-yaml">- alias: 'Telegram bot repeats arguments on callback query'
  trigger:
    platform: event
    event_type: telegram_callback
    event_data:
      command: '/repeat'
  action:
    - service: telegram_bot.answer_callback_query
      data_template:
        show_alert: true
        callback_query_id: '{{ trigger.event.data.id }}'
        message: 'I repeat: {{trigger.event.data["args"]}}'
</code></pre>
<p>이 경우, <code>/ repeat 1 2 3</code>으로 콜백을 하면 팝업창에 <code>I repeat : [1, 2, 3]</code> 라고 알림이 뜹니다.</p>
<p><code>telegram_bot</code> 기능을보다 복잡하게 사용하려면 <a href="/docs/ecosystem/appdaemon/tutorial/">AppDaemon</a>을 사용하는 것이 좋습니다.</p>
<p>이것이 바로 이전의 4가지의 자동화가 간단한 AppDaemon 앱을 통한 방법입니다 :</p>
<pre><code class="language-python">import appdaemon.plugins.hass.hassapi as hass


class TelegramBotEventListener(hass.Hass):
    """Event listener for Telegram bot events."""

    def initialize(self):
        """Listen to Telegram Bot events of interest."""
        self.listen_event(self.receive_telegram_text, "telegram_text")
        self.listen_event(self.receive_telegram_callback, "telegram_callback")

    def receive_telegram_text(self, event_id, payload_event, *args):
        """Text repeater."""
        assert event_id == "telegram_text"
        user_id = payload_event["user_id"]
        msg = "You said: ``` %s ```" % payload_event["text"]
        keyboard = [
            [("Edit message", "/edit_msg"), ("Don't", "/do_nothing")],
            [("Remove this button", "/remove button")],
        ]
        self.call_service(
            "telegram_bot/send_message",
            title="*Dumb automation*",
            target=user_id,
            message=msg,
            disable_notification=True,
            inline_keyboard=keyboard,
        )

    def receive_telegram_callback(self, event_id, payload_event, *args):
        """Event listener for Telegram callback queries."""
        assert event_id == "telegram_callback"
        data_callback = payload_event["data"]
        callback_id = payload_event["id"]
        chat_id = payload_event["chat_id"]
        # keyboard = ["Edit message:/edit_msg, Don't:/do_nothing",
        #             "Remove this button:/remove button"]
        keyboard = [
            [("Edit message", "/edit_msg"), ("Don't", "/do_nothing")],
            [("Remove this button", "/remove button")],
        ]

        if data_callback == "/edit_msg":  # Message editor:
            # Answer callback query
            self.call_service(
                "telegram_bot/answer_callback_query",
                message="Editing the message!",
                callback_query_id=callback_id,
                show_alert=True,
            )

            # Edit the message origin of the callback query
            msg_id = payload_event["message"]["message_id"]
            user = payload_event["from_first"]
            title = "*Message edit*"
            msg = "Callback received from %s. Message id: %s. Data: ``` %s ```"
            self.call_service(
                "telegram_bot/edit_message",
                chat_id=chat_id,
                message_id=msg_id,
                title=title,
                message=msg % (user, msg_id, data_callback),
                inline_keyboard=keyboard,
            )

        elif data_callback == "/remove button":  # Keyboard editor:
            # Answer callback query
            self.call_service(
                "telegram_bot/answer_callback_query",
                message="Callback received for editing the " "inline keyboard!",
                callback_query_id=callback_id,
            )

            # Edit the keyboard
            new_keyboard = keyboard[:1]
            self.call_service(
                "telegram_bot/edit_replymarkup",
                chat_id=chat_id,
                message_id="last",
                inline_keyboard=new_keyboard,
            )

        elif data_callback == "/do_nothing":  # Only Answer to callback query
            self.call_service(
                "telegram_bot/answer_callback_query",
                message="OK, you said no!",
                callback_query_id=callback_id,
            )
</code></pre>


</article>

          
        </div>

        
        <aside id="sidebar" class="grid__item one-third lap-one-whole palm-one-whole">
          <div class="grid">
  
  
    <section class="aside-module grid__item one-whole lap-one-half">

<div class='edit-github'><a href='https://github.com/hakorea/gitpages_source/blob/master/source/_integrations/telegram_chatbot.markdown'>깃허브 편집</a></div>

<div class='brand-logo-container section'><img src='/images/supported_brands/telegram.png' /></div><div class="section">
    <kb-alert-link integration="telegram_chatbot"></kb-alert-link>
  </div><div class='section'>
      IoT class<sup><a href='/blog/2016/02/12/classifying-the-internet-of-things/#classifiers'><i class="icon-info-sign"></i></a></sup>: Cloud Push
    </div><div class='section'>
      Introduced in release: 0.42
    </div><div class='section'>
    Source: <a href='https://github.com/home-assistant/home-assistant/blob/dev/homeassistant/components/telegram_chatbot/'>/components/telegram_chatbot/</a>
  </div><div class='section'>
    <h1 class="title delta">카테고리</h1>
    <ul class='divided'><li>
        <a href='/integrations/#hub'>Hub</a>
      </li></ul>
    </div></section>

<script src="https://alerts.home-assistant.io/ce-alert-link.js"></script>

  
</div>

        </aside>
        
      </div>
    </div>

    <footer>
      <div class="grid-wrapper">
  <div class="grid">
    <div class="grid__item">
      <div class="copyright grid">
        <div class='company grid__item one-third lap-one-half palm-one-whole'>
          <div class="title">
            <img src="/images/home-assistant-logo.png" width="36" height="36" alt="Home Assistant"> 홈어시스턴트
          </div>
        </div>

        <div class='grid__item one-third lap-one-half palm-one-whole'>
          <ul>
            <li><a href='https://alerts.home-assistant.io'>Home Assistant Alerts</a></li>
            <li><a href='https://cafe.naver.com/koreassistant'>HA 네이버 카페</a></li>
          </ul>
        </div>

        <div class='grid__item one-third lap-one-half palm-one-whole'>
          이 웹사이트는 <a href='https://jekyllrb.com/'>Jekyll</a>과
          <a href='https://github.com/coogie/oscailte'>Oscalite 테마</a>를 사용합니다.
        </div>
      </div>
    </div>
  </div>
</div>

    </footer>

    <script>
var _gaq=[['_setAccount',''],['_trackPageview']];
(function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
s.parentNode.insertBefore(g,s)}(document,'script'));
</script>

<script src="/javascripts/prism.js?5d6619066a1fc5cd819a93c132b539ac" type="text/javascript"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
  apiKey: 'c762b5632da4220f398f985614f3a1e3',
  indexName: 'hakorea',
  inputSelector: '#search',
  debug: false // Set debug to true if you want to inspect the dropdown
});
document.querySelector('.search .close').addEventListener('click', function(ev) {
  ev.preventDefault();
  document.querySelector('.search-container').style.display = 'none';
});
document.querySelector('.show-search').addEventListener('click', function(ev) {
  ev.preventDefault();
  document.querySelector('.search-container').style.display = 'block';
  document.getElementById('toggle').checked = false;
  document.querySelector('.search-container input').focus();
});
</script>

  </body>
</html>
