I"<p>Receive signals from a keyboard and use it as a remote control.</p>
<p>This integration allows you to use one or more keyboards as remote controls. It will fire <code>keyboard_remote_command_received</code> events which can then be used in automation rules.</p>
<p>The <code>evdev</code> package is used to interface with the keyboard and thus this is Linux only. It also means you can’t use your normal keyboard for this because <code>evdev</code> will block it.</p>
<pre><code class="language-yaml"># Example configuration.yaml entry
keyboard_remote:
  type: 'key_up'
</code></pre>
<div class="config-vars">
  <h3><a class="title-link" name="configuration-variables" href="#configuration-variables"></a> Configuration Variables</h3>
  <dl class=''><dt><a class='title-link' name='type' href='#type'></a> type</dt><dd><p class='desc'><span class='type'>(<span class='string'>string</span>)</span><span class='required'>(Required)</span><span class='description'><p>Possible values are <code>key_up</code>, <code>key_down</code>, and <code>key_hold</code>. Be careful, <code>key_hold</code> will fire a lot of events.  This can be a list of types.</p>
</span></p></dd><dt><a class='title-link' name='emulate_key_hold' href='#emulate_key_hold'></a> emulate_key_hold</dt><dd><p class='desc'><span class='type'>(<span class='boolean'>boolean</span>)</span><span class='required'>(Optional)</span><span class='description'><p>Emulate key hold events when key is held down.  (Some input devices do not send these otherwise.)</p>
</span></p><p class='default'>
Default value: <p>false</p>
</p></dd><dt><a class='title-link' name='emulate_key_hold_delay' href='#emulate_key_hold_delay'></a> emulate_key_hold_delay</dt><dd><p class='desc'><span class='type'>(<span class='float'>float</span>)</span><span class='required'>(Optional)</span><span class='description'><p>Number of milliseconds to wait before sending first emulated key hold event</p>
</span></p><p class='default'>
Default value: <p>0.25</p>
</p></dd><dt><a class='title-link' name='emulate_key_hold_repeat' href='#emulate_key_hold_repeat'></a> emulate_key_hold_repeat</dt><dd><p class='desc'><span class='type'>(<span class='float'>float</span>)</span><span class='required'>(Optional)</span><span class='description'><p>Number of milliseconds to wait before sending subsequent emulated key hold event</p>
</span></p><p class='default'>
Default value: <p>0.033</p>
</p></dd><dt><a class='title-link' name='device_descriptor' href='#device_descriptor'></a> device_descriptor</dt><dd><p class='desc'><span class='type'>(<span class='string'>string</span>)</span><span class='required'>(Optional)</span><span class='description'><p>Path to the local event input device file that corresponds to the keyboard.</p>
</span></p></dd><dt><a class='title-link' name='device_name' href='#device_name'></a> device_name</dt><dd><p class='desc'><span class='type'>(<span class='string'>string</span>)</span><span class='required'>(Optional)</span><span class='description'><p>Name of the keyboard device.</p>
</span></p></dd></dl>
</div>
<p>Either <code>device_name</code> or <code>device_descriptor</code> must be present in the configuration entry. Indicating a device name is useful in case of repeating disconnections and re-connections of the device (for example, a bluetooth keyboard): the local input device file might change, thus breaking the configuration, while the name remains the same.
In case of presence of multiple devices of the same model, <code>device_descriptor</code> must be used.</p>
<p>A list of possible device descriptors and names is reported in the debug log at startup when the device indicated in the configuration entry could not be found.</p>
<p>A full configuration for two Keyboard Remotes could look like the one below:</p>
<pre><code class="language-yaml">keyboard_remote:
- device_descriptor: '/dev/input/by-id/bluetooth-keyboard'
  type: 'key_down'
  emulate_key_hold: true
  emulate_key_hold_delay: 250
  emulate_key_hold_repeat: 33
- device_descriptor: '/dev/input/event0'
  type:
    - 'key_up'
    - 'key_down'
</code></pre>
<p>Or like the following for one keyboard:</p>
<pre><code class="language-yaml">keyboard_remote:
  device_name: 'Bluetooth Keyboard'
  type: 'key_down'
</code></pre>
<p>And an automation rule to breathe life into it:</p>
<pre><code class="language-yaml">automation:
  alias: Keyboard all lights on
  trigger:
    platform: event
    event_type: keyboard_remote_command_received
    event_data:
      device_descriptor: &quot;/dev/input/event0&quot;
      key_code: 107 # inspect log to obtain desired keycode
  action:
    service: light.turn_on
    entity_id: light.all
</code></pre>
<p><code>device_descriptor</code> or <code>device_name</code> may be specificed in the trigger so the automation will be fired only for that keyboard. This is especially useful if you wish to use several bluetooth remotes to control different devices. Omit them to ensure the same key triggers the automation for all keyboards/remotes.</p>
<h2>Disconnections</h2>
<p>This integration manages disconnections and re-connections of the keyboard, for example in the case of a Bluetooth device that turns off automatically to preserve battery.</p>
<p>If the keyboard disconnects, the integration will fire an event <code>keyboard_remote_disconnected</code>.
When the keyboard reconnects, an event <code>keyboard_remote_connected</code> will be fired.</p>
<p>Here’s an automation example that plays a sound through a media player whenever the keyboard connects/disconnects:</p>
<pre><code class="language-yaml">automation:
  - alias: Keyboard Connected
    trigger:
      platform: event
      event_type: keyboard_remote_connected
    action:
      - service: media_player.play_media
        data:
          entity_id: media_player.speaker
          media_content_id: keyboard_connected.wav
          media_content_type: music

  - alias: Bluetooth Keyboard Disconnected
    trigger:
      platform: event
      event_type: keyboard_remote_disconnected
      event_data:
        device_name: &quot;00:58:56:4C:C0:91&quot;
    action:
      - service: media_player.play_media
        data:
          entity_id: media_player.speaker
          media_content_id: keyboard_disconnected.wav
          media_content_type: music
</code></pre>
<h2>Permissions</h2>
<p>There might be permissions problems with the event input device file. If this is the case, the user that Home Assistant runs as must be allowed read and write permissions with:</p>
<pre><code class="language-bash">sudo setfacl -m u:HASS_USER:rw /dev/input/event*
</code></pre>
<p>Where <code>HASS_USER</code> is the user who runs Home Assistant.</p>
<p>If you want to make this permanent, you can use a udev rule that sets it for all event input devices. Add a file <code>/etc/udev/rules.d/99-userdev-input.rules</code> containing:</p>
<pre><code class="language-bash">KERNEL==&quot;event*&quot;, SUBSYSTEM==&quot;input&quot;, RUN+=&quot;/usr/bin/setfacl -m u:HASS_USER:rw $env{DEVNAME}&quot;
</code></pre>
<p>You can check ACLs permissions with:</p>
<pre><code class="language-bash">getfacl /dev/input/event*
</code></pre>
:ET