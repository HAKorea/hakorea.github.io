I"&<p>Text-to-Speech (TTS) enables Home Assistant to speak to you.</p>
<h2>Configuring a <code>tts</code> platform</h2>
<p>To get started, add the following lines to your <code>configuration.yaml</code> (example for Google):</p>
<pre><code class="language-yaml"># Example configuration.yaml entry for Google TTS service
tts:
  - platform: google_translate
</code></pre>
<div class='note'>
<p>Depending on your setup, you might need to set a base URL (<code>base_url</code>) inside the <a href="/integrations/http/">http component</a> or in the parameters of this component.</p>
</div>
<p>The following optional parameters can be used with any platform. However, the TTS integration will only look for global settings under the configuration of the first configured platform:</p>
<div class="config-vars">
  <h3><a class="title-link" name="configuration-variables" href="#configuration-variables"></a> Configuration Variables</h3>
  <dl class=''><dt><a class='title-link' name='cache' href='#cache'></a> cache</dt><dd><p class='desc'><span class='type'>(<span class='boolean'>boolean</span>)</span><span class='required'>(Optional)</span><span class='description'><p>Allow TTS to cache voice file to local storage.</p>
</span></p><p class='default'>
Default value: <p>true</p>
</p></dd><dt><a class='title-link' name='cache_dir' href='#cache_dir'></a> cache_dir</dt><dd><p class='desc'><span class='type'>(<span class='string'>string</span>)</span><span class='required'>(Optional)</span><span class='description'><p>Folder name or path to a folder for caching files.</p>
</span></p><p class='default'>
Default value: <p>tts</p>
</p></dd><dt><a class='title-link' name='time_memory' href='#time_memory'></a> time_memory</dt><dd><p class='desc'><span class='type'>(<span class='integer'>integer</span>)</span><span class='required'>(Optional)</span><span class='description'><p>Time to hold the voice data inside memory for fast play on a media player. Minimum is 60 s and the maximum 57600 s (16 hours).</p>
</span></p><p class='default'>
Default value: <p>300</p>
</p></dd><dt><a class='title-link' name='base_url' href='#base_url'></a> base_url</dt><dd><p class='desc'><span class='type'>(<span class='string'>string</span>)</span><span class='required'>(Optional)</span><span class='description'><p>A base URL to use <em>instead</em> of the one set in the <a href="/integrations/http/">http component</a>. It is used as-is by the <code>tts</code> component. In particular, you need to include the protocol scheme <code>http://</code> or <code>https://</code> and the correct port number. They will not be automatically added for you.</p>
</span></p><p class='default'>
Default value: <p>value of <code>http.base_url</code></p>
</p></dd><dt><a class='title-link' name='service_name' href='#service_name'></a> service_name</dt><dd><p class='desc'><span class='type'>(<span class='string'>string</span>)</span><span class='required'>(Optional)</span><span class='description'><p>Define the service name.</p>
</span></p><p class='default'>
Default value: <p>The service name default set to <platform>_say. For example, for google_translate tts, its service name default is <code>google_translate_say</code>.</p>
</p></dd></dl>
</div>
<p>The extended example from above would look like the following sample:</p>
<pre><code class="language-yaml"># Example configuration.yaml entry for Google Translate TTS service
tts:
  - platform: google_translate
    cache: true
    cache_dir: /tmp/tts
    time_memory: 300
    base_url: http://192.168.0.10:8123
    service_name: google_say
</code></pre>
<div class='note'>
<p>In the above example, <code>base_url</code> is custom to this particular TTS platform configuration. It is not suggesting that you use the <code>base_url</code> that you have set for your core Home Assistant configuration. The reason you might need to do this is outlined in the next section.</p>
</div>
<h2>When do you need to set <code>base_url</code> here?</h2>
<p>The general answer is “whenever the global <code>base_url</code> set in <a href="/integrations/http/">http component</a> is not adequate to allow the <code>say</code> service to run”. The <code>say</code> service operates by generating a media file that contains the speech corresponding to the text passed to the service. Then the <code>say</code> service sends a message to the media device with a URL pointing to the file. The device fetches the media file at the URL and plays the media. Some combinations of a media device, network configuration and Home Assistant configuration can make it so that the device cannot fetch the media file.</p>
<p>The following sections describe some of the problems encountered with media devices.</p>
<h3>Self-signed certificates</h3>
<p>This problem occurs when your Home Assistant instance is configured to be accessed through SSL, and you are using a self-signed certificate.</p>
<p>The <code>tts</code> service will send an <code>https://</code> URL to the media device, which will check the certificate, and reject it. So it won’t play your file. If you could make the device accept your certificate, it would play the file. However, many media devices do not allow changing settings to accept self-signed certificates. Ultimately, your option may be to serve files to the device as <code>http://</code> rather than <code>https://</code>. To do this, you <em>could</em> change the <code>base_url</code> setting in <a href="/integrations/http/">http component</a>, but that would turn off SSL for all services that use <code>base_url</code>. Instead, setting a <code>base_url</code> for the <code>tts</code> service allows turning off SSL only for this component.</p>
<h3>Google cast devices</h3>
<p>The Google cast devices (Google Home, Chromecast, etc.) present the following problems:</p>
<ul>
<li>
<p>They <a href="#self-signed-certificates">reject self-signed certificates</a>.</p>
</li>
<li>
<p>They do not work with URLs that contain hostnames established by local naming means. Let’s say your Home Assistant instance is running on a machine made known locally as <code>ha</code>. All your machines on your local network are able to access it as <code>ha</code>. However, try as you may, your cast device won’t download the media files from your <code>ha</code> machine. That’s because your cast device ignores your local naming setup. In this example, the <code>say</code> service creates a URL like <code>http://ha/path/to/media.mp3</code> (or <code>https://...</code> if you are using SSL). Setting a <code>base_url</code> that contains the IP address of your server works around this issue. By using an IP address, the cast device does not have to resolve the hostname.</p>
</li>
<li>
<p>An alternative way to force Google cast devices to use internal DNS is to block them from accessing Google DNS at the firewall/router level. This would be useful in the case, for example, where your internal IP of Home Assistant is a private IP and you have your internal DNS server (quite often a split-brain DNS scenario). This method works on both Google Home Mini and Google Chromecasts.</p>
</li>
</ul>
<h2>Service say</h2>
<p>The <code>say</code> service support <code>language</code> and on some platforms also <code>options</code> for set, i.e., <em>voice, motion, speed, etc</em>. The text for speech is set with <code>message</code>. Since release 0.92, service name can be defined in configuration <code>service_name</code> option.</p>
<p>Say to all <code>media_player</code> device entities:</p>
<pre><code class="language-yaml"># Replace google_translate_say with &lt;platform&gt;_say when you use a different platform.
service: tts.google_translate_say
entity_id: &quot;all&quot;
data:
  message: 'May the Force be with you.'
</code></pre>
<p>Say to the <code>media_player.floor</code> device entity:</p>
<pre><code class="language-yaml">service: tts.google_translate_say
entity_id: media_player.floor
data:
  message: 'May the Force be with you.'
</code></pre>
<p>Say to the <code>media_player.floor</code> device entity in French:</p>
<pre><code class="language-yaml">service: tts.google_translate_say
entity_id: media_player.floor
data:
  message: 'Que la force soit avec toi.'
  language: 'fr'
</code></pre>
<p>With a template:</p>
<pre><code class="language-yaml">service: tts.google_translate_say
data_template:
  message: &quot;Temperature is {{states('sensor.temperature')}}.&quot;
  cache: false
</code></pre>
<h2>Cache</h2>
<p>The integration has two caches. Both caches can be controlled with the <code>cache</code> option in the platform configuration or the service call <code>say</code>. A long time cache will be located on the file system. The in-memory cache for fast responses to media players will be auto-cleaned after a short period.</p>
<h2>REST Api</h2>
<h3>POST /api/tts_get_url</h3>
<p>Returns an URL to the generated TTS file. Platform and message are required.</p>
<pre><code class="language-json">{
    &quot;platform&quot;: &quot;amazon_polly&quot;,
    &quot;message&quot;: &quot;I am speaking now&quot;
}
</code></pre>
<p>The return code is 200 if the file is generated. The message body will contain a JSON object with the URL.</p>
<pre><code class="language-json">{
    &quot;url&quot;: &quot;http://127.0.0.1:8123/api/tts_proxy/265944c108cbb00b2a621be5930513e03a0bb2cd_en_-_demo.mp3&quot;
}
</code></pre>
<p>Sample <code>curl</code> command:</p>
<pre><code class="language-bash">$ curl -X POST -H &quot;x-ha-access: YOUR_PASSWORD&quot; \
       -H &quot;Content-Type: application/json&quot; \
       -d '{&quot;message&quot;: &quot;I am speaking now&quot;, &quot;platform&quot;: &quot;amazon_polly&quot;}' \
       http://localhost:8123/api/tts_get_url
</code></pre>
:ET